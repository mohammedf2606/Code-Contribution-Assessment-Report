\chapter{Conclusion}

The aim of this project was to create a means of reporting code contributions to a shared code repository. The proposed ranking algorithm and the resulting infrastructure definitely has attained this goal. As a project, it contributes towards the development of better measurements of code contributions. The development of these measures are imperative given the amount of work being put into crowd sourced projects over the past few years as well as their rise in popularity. Group software engineering projects have also become a common assessment tool in university, where assessment is based on the contributions you provided to the group. The proposed algorithm and infrastructure provides an alternative approach in measuring contributions with quality taken into account. It is a code independent, quality aware, change versatile and change resistant ranking algorithm tailored for student-led group projects and ranking the contributors fairly and distributing the marks depending on these contributions. 

\section{Future Work}
There are many considerations and inferences made that may skew rankings generated by the algorithm and that need to be addressed for the proposed ranking system in any future developments based off this project. 

Although movement of lines can be detected using the $threshold$ variable and the log transforms, movement within lines are still not detected. For instance, the texts “if i $\geq$ 1:” and “if 1 $\leq$ i:” will result in only some characters to be detected as common. However, it's clear that this if statement had all of its components rearranged. An alternative approach that was been tried during development of the algorithm was to understand what has moved based on the minimum size of characters (looking at substrings instead of lines). However, this resulted in a reduced accuracy. Using a n-grams based approach \citep{wiki:ngram} may improve the accuracy in the results but the approach will increase the complexity of the algorithm by a large degree. Even so, within line code rearrangements as discussed in the above example are very rare but this restriction in the algorithm needs to be considered when the proposed algorithm is used.

The Gestalt pattern matching similarity mechanism should also be criticised as it is a large part of the algorithm. The following example shows an interesting feature of the pattern matching algorithm's use of a ratio based score. Using the algorithm on the two strings “abc” and “abcdefgh” will give a higher similarity ratio of 0.54 than a comparison between “abcdefgh” and “abcxyzjk” which gives a similarity score of 0.38. This shows that if more dissimilar characters occur between any two strings, the lesser the similarity score. Therefore, having fewer characters in a string boosts the similarity score only if the substrings are conserved. This may not be a restriction of the proposed algorithm itself but since it is fundamental to the algorithm (as seen in Algorithm 1), it needs to be considered when evaluating the algorithm. An alternative method for this would penalise similarity scores based on the lack of characters or use another similarity metric such as Jaccard Similarity coefficient \citep{stephanie_2016}. 

The proposed algorithm’s performance is wholly dependent on the size of the repository (in terms of commits) and the contributors' behaviour. For example, smaller projects, such as personal projects, may not provide the same performance in detecting the quality of the codebase or showing accurate rankings. Since the algorithm was created with the student group project environment in mind (as per the brief), restrictions may emerge and results may vary when the algorithm is applied elsewhere to other repositories. 

This project was more focused on developing an algorithm for measuring code contributions accurately. This has meant that the visualisations created for the user to understand are quite simplistic. More advanced visualisations can easily be developed using different charting libraries. This can result in complex network-like visualisations like those seen in Gource \citep{caudwell_2017}.
